---
layout: post
title:  分布式类常见问题汇总
categories: [分布式]
excerpt: 新建文章时或查看Markdown语法时可以参考此模板.
---
#### 分布式幂等性如何设计？
在高并发场景的架构里，幂等性是必须得保证的。比如说支付功能，用户发起支付，如果后台没有做幂等校验，刚好用户手抖多点了几下，于是后台就可能多次受到同一个订单请求，不做幂等很容易就让用户重复支付了，这样用户是肯定不能忍的。  
**解决方案**  
1. 查询和删除不在幂等讨论范围，查询肯定没有幂等的说，删除：第一次删除成功后，后面来删除直接返回0，也是返回成功。  
2. 建唯一索引，唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增异常时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。
3. token机制，由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交。前端在数据提交前要向后端服务的申请token，token放到 Redis 或 JVM 内存，token有效时间。提交后后台校验token，同时删除token，生成新的token返回。redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用。
4. 悲观锁
```sql
select id ,name from table_# where id='##' for update;
```
悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用（另外还要考虑id是否为主键，如果id不是主键或者不是 InnoDB 存储引擎，那么就会出现锁全表）。
5. 乐观锁，给数据库表增加一个version字段，可以通过这个字段来判断是否已经被修改了
```sql
update table_xxx set name=#name#,version=version+1 where version=#version#
```
6. 分布式锁，比如 Redis 、 Zookeeper 的分布式锁。单号为key，然后给Key设置有效期（防止支
付失败后，锁一直不释放），来一个请求使用订单号生成一把锁，业务代码执行完成后再释放锁。
7. 保底方案，先查询是否存在此单，不存在进行支付，存在就直接返回支付结果。

---
#### 说说你对分布式事务的了解
分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免。  
首先要搞清楚：ACID、CAP、BASE理论。  
**ACID **
指数据库事务正确执行的四个基本要素：
1. 原子性（Atomicity）
2. 一致性（Consistency）
3. 隔离性（Isolation）
4. 持久性（Durability）  

**CAP**
CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。  
CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。  
- 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
- 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
- 分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。  

**BASE理论**  
BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。
- Basically Available（基本可用）
- Soft state（软状态）
- Eventually consistent（最终一致性）

#### 、你知道哪些分布式事务解决方案？
我目前知道的有五种：
1. 两阶段提交(2PC)
2. 三阶段提交(3PC)
3. 补偿事务(TCC=Try-Confirm-Cancel)
4. 本地消息队列表(MQ)
5. Sagas事务模型(最终一致性)
说完上面五种，面试官一般都会继续问下面这几个问题（可能就问一两个，也可能全部问）。

**两阶段提交**  
两阶段提交2PC是分布式事务中最强大的事务类型之一，两段提交就是分两个阶段提交：  
**第一阶段询问各个事务数据源是否准备好。**  
**第二阶段才真正将数据提交给事务数据源。**  
为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者（Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。  
处理流程如下：  
**阶段一**  
1. 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。
2. 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。
3. 如参与者执行成功，给协调者反馈 yes，否则反馈 no。
**阶段二**  
如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息。  
两种情况处理如下：  
情况1：当所有参与者均反馈 yes，提交事务
1. 协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。
2. 参与者执行 commit 请求，并释放整个事务期间占用的资源。
3. 各参与者向协调者反馈 ack(应答)完成的消息。
4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。
情况2：当有一个参与者反馈 no，回滚事务
1. 协调者向所有参与者发出回滚请求（即 rollback 请求）。
2. 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。
3. 各参与者向协调者反馈 ack 完成的消息。
4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务。
**问题**
1. 性能问题  
   所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。
2. 可靠性问题
   如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。
3. 数据一致性问题：在阶段 2 中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。

**优点**：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证
强一致）。
**缺点**：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。
#### 什么是三阶段提交？
三阶段提交是在二阶段提交上的改进版本，3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交。  
处理流程如下 ：
![3pc](/images/2022/03/3pc.png)  

**阶段一**
1. 协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。
2. 参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。
**阶段二**  

协调者根据参与者响应情况，有以下两种可能。  
**情况1**：所有参与者均反馈 yes，协调者预执行事务
1.  协调者向所有参与者发出 preCommit 请求，进入准备阶段。
2. 参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。
3. 各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。
**情况2**：只要有一个参与者反馈 no，或者等待超时后协调者尚无法收到所有提供者的反馈，即中断事务
1. 协调者向所有参与者发出 abort 请求。
2. 无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。
**阶段三**  

该阶段进行真正的事务提交，也可以分为以下两种情况。
**情况 1**：所有参与者均反馈 ack 响应，执行真正的事务提交
1. 如果协调者处于工作状态，则向所有参与者发出 do Commit 请求。
2. 参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。
3. 各参与者向协调者反馈 ack 完成的消息。
4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。
**情况2**：只要有一个参与者反馈 no，或者等待超时后协调组尚无法收到所有提供者的反馈，即回滚
事务。
1. 如果协调者处于工作状态，向所有参与者发出 rollback 请求。
2. 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。
3. 各参与者向协调组反馈 ack 完成的消息。
4. 协调组收到所有参与者反馈的 ack 消息后，即完成事务回滚。  

**优点：**相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。
避免了协调者单点问题。阶段 3 中协调者出现问题时，参与者会继续提交事务。
**缺点：**数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时，
此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。
